<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Urban Wind Flow</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, system-ui, sans-serif;
            background: #000;
            overflow: hidden;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 12px;
            color: #fff;
            width: 280px;
            z-index: 100;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.6;
            margin-bottom: 5px;
        }
        
        .slider {
            width: 100%;
            -webkit-appearance: none;
            height: 2px;
            background: rgba(255,255,255,0.1);
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #fff;
            font-size: 10px;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 4px;
        }
        
        .layer-toggle {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .layer-btn {
            flex: 1;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .layer-btn.active {
            background: rgba(255,255,255,0.3);
            border-color: #fff;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 12px;
            letter-spacing: 2px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="loading">LOADING VELOCITY FIELD...</div>
    
    <div class="controls">
        <div class="control-group">
            <label>Wind Speed</label>
            <input type="range" class="slider" id="windSpeed" min="0" max="30" value="10" step="0.5">
            <span id="windSpeedValue">10 m/s</span>
        </div>
        
        <div class="control-group">
            <label>Wind Direction</label>
            <input type="range" class="slider" id="windDirection" min="0" max="360" value="270" step="5">
            <span id="windDirectionValue">270°</span>
        </div>
        
        <div class="control-group">
            <label>Particle Count</label>
            <input type="range" class="slider" id="particleCount" min="1000" max="50000" value="10000" step="1000">
            <span id="particleCountValue">10000</span>
        </div>
        
        <div class="control-group">
            <label>Particle Speed</label>
            <input type="range" class="slider" id="particleSpeed" min="0.1" max="5" value="1" step="0.1">
        </div>
        
        <div class="control-group">
            <label>Visualization</label>
            <div class="layer-toggle">
                <button class="layer-btn active" data-mode="flow">Flow</button>
                <button class="layer-btn" data-mode="pressure">Pressure</button>
                <button class="layer-btn" data-mode="vorticity">Vorticity</button>
            </div>
        </div>
        
        <div class="control-group">
            <label>Layers</label>
            <div class="layer-toggle">
                <button class="layer-btn active" data-layer="buildings">Buildings</button>
                <button class="layer-btn" data-layer="terrain">Terrain</button>
            </div>
        </div>
    </div>
    
    <div class="stats">
        <div>FPS: <span id="fps">60</span></div>
        <div>Particles: <span id="activeParticles">0</span></div>
        <div>Velocity: <span id="maxVelocity">0</span> m/s</div>
    </div>

    <script>
        class WindFlowVisualization {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                this.particles = [];
                this.velocityField = null;
                this.buildingMask = null;
                this.terrainData = null;
                
                // Grid params matching CFD simulation
                this.gridWidth = 400;
                this.gridHeight = 400;
                this.cellSize = 5; // meters
                
                // Rendering params
                this.particleCount = 10000;
                this.particleSpeed = 1;
                this.fadeOpacity = 0.98;
                this.lineWidth = 1;
                this.colorMode = 'flow';
                
                // Wind params
                this.windSpeed = 10;
                this.windDirection = 270;
                
                // Performance
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.fps = 60;
                
                this.init();
            }
            
            async init() {
                this.setupCanvas();
                await this.loadVelocityField();
                await this.loadTerrainData();
                this.initParticles();
                this.setupControls();
                this.animate();
                
                document.getElementById('loading').style.display = 'none';
            }
            
            setupCanvas() {
                const resize = () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    this.scaleX = this.canvas.width / this.gridWidth;
                    this.scaleY = this.canvas.height / this.gridHeight;
                };
                resize();
                window.addEventListener('resize', resize);
                
                // Performance: disable image smoothing
                this.ctx.imageSmoothingEnabled = false;
            }
            
            async loadVelocityField() {
                // Simulate loading CFD data from backend
                // In production: fetch from skrypt2_wiatr.py output
                
                try {
                    // Try loading actual data
                    const response = await fetch('./wyniki/rastry/wind_velocity_field.json');
                    if (response.ok) {
                        const data = await response.json();
                        this.velocityField = data;
                    } else {
                        this.generateSyntheticField();
                    }
                } catch {
                    this.generateSyntheticField();
                }
            }
            
            generateSyntheticField() {
                // Generate realistic urban wind field with building wakes
                this.velocityField = {
                    u: new Float32Array(this.gridWidth * this.gridHeight),
                    v: new Float32Array(this.gridWidth * this.gridHeight),
                    buildings: new Uint8Array(this.gridWidth * this.gridHeight)
                };
                
                const rad = this.windDirection * Math.PI / 180;
                const baseU = Math.sin(rad) * this.windSpeed;
                const baseV = Math.cos(rad) * this.windSpeed;
                
                for (let y = 0; y < this.gridHeight; y++) {
                    for (let x = 0; x < this.gridWidth; x++) {
                        const idx = y * this.gridWidth + x;
                        
                        // Add building obstacles (synthetic)
                        const buildingNoise = this.noise2D(x * 0.02, y * 0.02);
                        const isBuilding = buildingNoise > 0.3 && 
                                         x > 100 && x < 300 && 
                                         y > 100 && y < 300;
                        
                        if (isBuilding) {
                            this.velocityField.buildings[idx] = 1;
                            this.velocityField.u[idx] = 0;
                            this.velocityField.v[idx] = 0;
                        } else {
                            // Flow around buildings with turbulence
                            let u = baseU;
                            let v = baseV;
                            
                            // Check for upstream buildings
                            const checkDist = 20;
                            let wake = 0;
                            
                            for (let d = 1; d < checkDist; d++) {
                                const checkX = Math.round(x - d * Math.sin(rad));
                                const checkY = Math.round(y - d * Math.cos(rad));
                                
                                if (checkX >= 0 && checkX < this.gridWidth && 
                                    checkY >= 0 && checkY < this.gridHeight) {
                                    const checkIdx = checkY * this.gridWidth + checkX;
                                    if (this.velocityField.buildings[checkIdx]) {
                                        wake = Math.exp(-d * 0.1);
                                        break;
                                    }
                                }
                            }
                            
                            // Apply wake turbulence
                            if (wake > 0) {
                                const turbulence = Math.sin(x * 0.5 + y * 0.3) * wake;
                                u *= (1 - wake * 0.7);
                                v *= (1 - wake * 0.7);
                                u += turbulence * 2;
                                v += Math.cos(x * 0.4) * turbulence;
                            }
                            
                            // Add general turbulence
                            u += this.noise2D(x * 0.05, y * 0.05) * 2;
                            v += this.noise2D(x * 0.05 + 100, y * 0.05) * 2;
                            
                            this.velocityField.u[idx] = u;
                            this.velocityField.v[idx] = v;
                        }
                    }
                }
                
                // Smooth the field (Gaussian blur for realism)
                this.smoothField();
            }
            
            smoothField() {
                const kernel = [0.0625, 0.125, 0.0625, 0.125, 0.25, 0.125, 0.0625, 0.125, 0.0625];
                const tempU = new Float32Array(this.velocityField.u);
                const tempV = new Float32Array(this.velocityField.v);
                
                for (let y = 1; y < this.gridHeight - 1; y++) {
                    for (let x = 1; x < this.gridWidth - 1; x++) {
                        const idx = y * this.gridWidth + x;
                        if (this.velocityField.buildings[idx]) continue;
                        
                        let sumU = 0, sumV = 0, k = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nIdx = (y + dy) * this.gridWidth + (x + dx);
                                if (!this.velocityField.buildings[nIdx]) {
                                    sumU += tempU[nIdx] * kernel[k];
                                    sumV += tempV[nIdx] * kernel[k];
                                }
                                k++;
                            }
                        }
                        
                        this.velocityField.u[idx] = sumU;
                        this.velocityField.v[idx] = sumV;
                    }
                }
            }
            
            async loadTerrainData() {
                // Load DEM/DSM data
                // In production: load actual NMT/NMPT rasters
                this.terrainData = new Float32Array(this.gridWidth * this.gridHeight);
                
                for (let i = 0; i < this.terrainData.length; i++) {
                    this.terrainData[i] = Math.sin(i * 0.001) * 10 + 50;
                }
            }
            
            initParticles() {
                this.particles = [];
                for (let i = 0; i < this.particleCount; i++) {
                    this.particles.push(this.createParticle());
                }
            }
            
            createParticle() {
                return {
                    x: Math.random() * this.gridWidth,
                    y: Math.random() * this.gridHeight,
                    age: 0,
                    maxAge: 100 + Math.random() * 100,
                    path: []
                };
            }
            
            updateParticle(particle) {
                const gridX = Math.floor(particle.x);
                const gridY = Math.floor(particle.y);
                
                if (gridX < 0 || gridX >= this.gridWidth - 1 || 
                    gridY < 0 || gridY >= this.gridHeight - 1) {
                    return this.createParticle();
                }
                
                // Bilinear interpolation for smooth movement
                const fx = particle.x - gridX;
                const fy = particle.y - gridY;
                
                const idx00 = gridY * this.gridWidth + gridX;
                const idx10 = gridY * this.gridWidth + gridX + 1;
                const idx01 = (gridY + 1) * this.gridWidth + gridX;
                const idx11 = (gridY + 1) * this.gridWidth + gridX + 1;
                
                const u = (1 - fx) * (1 - fy) * this.velocityField.u[idx00] +
                         fx * (1 - fy) * this.velocityField.u[idx10] +
                         (1 - fx) * fy * this.velocityField.u[idx01] +
                         fx * fy * this.velocityField.u[idx11];
                         
                const v = (1 - fx) * (1 - fy) * this.velocityField.v[idx00] +
                         fx * (1 - fy) * this.velocityField.v[idx10] +
                         (1 - fx) * fy * this.velocityField.v[idx01] +
                         fx * fy * this.velocityField.v[idx11];
                
                // Check for building collision
                if (this.velocityField.buildings[idx00]) {
                    return this.createParticle();
                }
                
                // Update position
                particle.x += u * this.particleSpeed * 0.1;
                particle.y += v * this.particleSpeed * 0.1;
                
                // Store path for trail effect
                particle.path.push({x: particle.x * this.scaleX, y: particle.y * this.scaleY});
                if (particle.path.length > 10) {
                    particle.path.shift();
                }
                
                particle.age++;
                
                if (particle.age > particle.maxAge) {
                    return this.createParticle();
                }
                
                return particle;
            }
            
            drawParticle(particle) {
                if (particle.path.length < 2) return;
                
                const speed = Math.sqrt(
                    Math.pow(particle.path[particle.path.length - 1].x - particle.path[0].x, 2) +
                    Math.pow(particle.path[particle.path.length - 1].y - particle.path[0].y, 2)
                );
                
                // Color based on speed
                const hue = this.colorMode === 'flow' ? 
                    200 - speed * 2 : // Blue to green
                    this.colorMode === 'pressure' ?
                    280 - speed * 3 : // Purple gradient
                    60 + speed * 2; // Yellow to red for vorticity
                    
                const saturation = 70 + speed;
                const lightness = 50 + speed * 0.5;
                const alpha = (1 - particle.age / particle.maxAge) * 0.8;
                
                this.ctx.strokeStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                this.ctx.lineWidth = this.lineWidth;
                this.ctx.beginPath();
                
                for (let i = 0; i < particle.path.length; i++) {
                    const point = particle.path[i];
                    if (i === 0) {
                        this.ctx.moveTo(point.x, point.y);
                    } else {
                        this.ctx.lineTo(point.x, point.y);
                    }
                }
                
                this.ctx.stroke();
            }
            
            drawBuildings() {
                this.ctx.fillStyle = 'rgba(20, 20, 30, 0.6)';
                
                for (let y = 0; y < this.gridHeight; y++) {
                    for (let x = 0; x < this.gridWidth; x++) {
                        const idx = y * this.gridWidth + x;
                        if (this.velocityField.buildings[idx]) {
                            this.ctx.fillRect(
                                x * this.scaleX,
                                y * this.scaleY,
                                this.scaleX,
                                this.scaleY
                            );
                        }
                    }
                }
            }
            
            animate() {
                // Fade effect
                this.ctx.fillStyle = `rgba(0, 0, 0, ${1 - this.fadeOpacity})`;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Update and draw particles
                for (let i = 0; i < this.particles.length; i++) {
                    this.particles[i] = this.updateParticle(this.particles[i]);
                    this.drawParticle(this.particles[i]);
                }
                
                // Draw buildings overlay
                if (document.querySelector('[data-layer="buildings"].active')) {
                    this.drawBuildings();
                }
                
                // Update stats
                this.updateStats();
                
                requestAnimationFrame(() => this.animate());
            }
            
            updateStats() {
                this.frameCount++;
                const now = performance.now();
                if (now - this.lastTime > 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastTime = now;
                    
                    document.getElementById('fps').textContent = this.fps;
                    document.getElementById('activeParticles').textContent = this.particles.length;
                    
                    // Calculate max velocity
                    let maxV = 0;
                    for (let i = 0; i < this.velocityField.u.length; i++) {
                        const v = Math.sqrt(
                            this.velocityField.u[i] ** 2 + 
                            this.velocityField.v[i] ** 2
                        );
                        maxV = Math.max(maxV, v);
                    }
                    document.getElementById('maxVelocity').textContent = maxV.toFixed(1);
                }
            }
            
            setupControls() {
                // Wind speed
                document.getElementById('windSpeed').addEventListener('input', (e) => {
                    this.windSpeed = parseFloat(e.target.value);
                    document.getElementById('windSpeedValue').textContent = `${this.windSpeed} m/s`;
                    this.generateSyntheticField();
                });
                
                // Wind direction
                document.getElementById('windDirection').addEventListener('input', (e) => {
                    this.windDirection = parseFloat(e.target.value);
                    document.getElementById('windDirectionValue').textContent = `${this.windDirection}°`;
                    this.generateSyntheticField();
                });
                
                // Particle count
                document.getElementById('particleCount').addEventListener('input', (e) => {
                    const newCount = parseInt(e.target.value);
                    document.getElementById('particleCountValue').textContent = newCount;
                    
                    if (newCount > this.particleCount) {
                        for (let i = this.particleCount; i < newCount; i++) {
                            this.particles.push(this.createParticle());
                        }
                    } else {
                        this.particles.splice(newCount);
                    }
                    this.particleCount = newCount;
                });
                
                // Particle speed
                document.getElementById('particleSpeed').addEventListener('input', (e) => {
                    this.particleSpeed = parseFloat(e.target.value);
                });
                
                // Visualization modes
                document.querySelectorAll('[data-mode]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-mode]').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.colorMode = e.target.dataset.mode;
                    });
                });
                
                // Layer toggles
                document.querySelectorAll('[data-layer]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.target.classList.toggle('active');
                    });
                });
            }
            
            // Simplex noise for realistic turbulence
            noise2D(x, y) {
                // Simplified Perlin noise
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const A = this.p[X] + Y;
                const B = this.p[X + 1] + Y;
                return this.lerp(v,
                    this.lerp(u, this.grad2(this.p[A], x, y), this.grad2(this.p[B], x - 1, y)),
                    this.lerp(u, this.grad2(this.p[A + 1], x, y - 1), this.grad2(this.p[B + 1], x - 1, y - 1))
                );
            }
            
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            grad2(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y;
                const v = h < 2 ? y : x;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
            
            p = new Uint8Array(512);
            
            constructor() {
                super();
                // Initialize permutation table
                for (let i = 0; i < 256; i++) {
                    this.p[i] = this.p[i + 256] = Math.floor(Math.random() * 256);
                }
            }
        }
        
        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            new WindFlowVisualization();
        });
    </script>
</body>
</html>
