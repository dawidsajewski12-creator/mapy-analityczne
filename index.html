<!DOCTYPE html>
<html lang="pl">
<head>
    <title>Mapy Analityczne</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/geotiff@2.0.7/dist-browser/geotiff.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-velocity-ts@1.1.0/dist/leaflet-velocity.js"></script>
    <style>
        html, body, #map { height: 100%; width: 100%; margin: 0; background: #2a2a2a; }
        .leaflet-control-layers-base label, .leaflet-control-layers-overlays label { color: #333; }
        .info-box { padding: 10px; background: rgba(255,255,255,0.9); box-shadow: 0 0 15px rgba(0,0,0,0.2); border-radius: 5px; }
        .legend .title { font-weight: bold; margin-bottom: 5px; text-align: center; font-size: 14px; }
        .legend i { width: 18px; height: 18px; float: left; margin-right: 8px; opacity: 0.9; border: 1px solid #ccc; }
        .legend .gradient { width: 100%; height: 18px; margin-top: 4px; border-radius: 3px; }
        .legend .labels { display: flex; justify-content: space-between; font-size: 12px; }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    const map = L.map('map').setView([54.16, 19.40], 13);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '© OpenStreetMap contributors, © CARTO'
    }).addTo(map);

    let velocityLayer = null;

    const overlayLayers = {
        "Pokrycie terenu": L.tileLayer('./wyniki/kafelki/landcover/{z}/{x}/{y}.png', { tms: true }),
        "Korony drzew": L.tileLayer('./wyniki/kafelki/korony_drzew/{z}/{x}/{y}.png', { tms: true }),
        "Model Terenu (NMT)": L.tileLayer('./wyniki/kafelki/nmt/{z}/{x}/{y}.png', { tms: true }),
        "Zasięg podtopień": L.tileLayer('./wyniki/kafelki/podtopienia/{z}/{x}/{y}.png', { tms: true }),
        "Prędkość wiatru": L.tileLayer('./wyniki/kafelki/wiatr/{z}/{x}/{y}.png', { tms: true, opacity: 0.5 }),
        "Komfort termiczny": L.tileLayer('./wyniki/kafelki/komfort/{z}/{x}/{y}.png', { tms: true })
    };
    L.control.layers(null, overlayLayers, { collapsed: false }).addTo(map);

    const legendControl = L.control({ position: "bottomright" });
    legendControl.onAdd = () => L.DomUtil.create("div", "legend-placeholder", "info-box");
    legendControl.addTo(map);

    function createGradientLegend(title, min, max, gradientCss) {
        const div = L.DomUtil.create("div", "legend");
        div.innerHTML = `
            <div class="title">${title}</div>
            <div class="gradient" style="background: ${gradientCss};"></div>
            <div class="labels">
                <span>${min}</span>
                <span>${((min + max) / 2).toFixed(1)}</span>
                <span>${max}</span>
            </div>
        `;
        return div;
    }

    const legends = {
        "Pokrycie terenu": () => {
            const div = L.DomUtil.create("div", "legend");
            const items = {
                'Nawierzchnie utwardzone': 'rgb(169, 169, 169)', 'Budynki': 'rgb(220, 20, 60)',
                'Drzewa / Lasy': 'rgb(34, 139, 34)', 'Trawa / Tereny zielone': 'rgb(124, 252, 0)',
                'Gleba / Nieużytki': 'rgb(210, 180, 140)', 'Woda': 'rgb(30, 144, 255)'
            };
            let labels = '<div class="title">Pokrycie terenu</div>';
            for (const key in items) {
                labels += `<div><i style="background:${items[key]}"></i>${key}</div>`;
            }
            div.innerHTML = labels;
            return div;
        },
        "Korony drzew": () => createGradientLegend("Wysokość drzew [m]", 4, 40, "linear-gradient(to right, #ffffcc, #006837)"),
        "Model Terenu (NMT)": () => createGradientLegend("Wysokość n.p.m.", 5, 95, "linear-gradient(to right, #398439, #e8e397, #bf8754)"),
        "Zasięg podtopień": () => createGradientLegend("Głębokość wody [m]", 0.01, 1.5, "linear-gradient(to right, #deebf7, #3182bd)"),
        "Prędkość wiatru": (weather) => {
            const div = createGradientLegend("Prędkość wiatru [m/s]", 0, (weather.wind_speed * 1.5).toFixed(1), "linear-gradient(to right, #fde725, #440154)");
            div.innerHTML += `<div style="font-size:12px; text-align:center; margin-top:5px;">Wiatr bazowy: ${weather.wind_speed.toFixed(1)} m/s, ${weather.wind_direction.toFixed(0)}°</div>`;
            return div;
        },
        "Komfort termiczny": (weather) => {
            const div = createGradientLegend("Odczuwalna temp. UTCI [°C]", 9, 38, "linear-gradient(to right, #4575b4, #ffffbf, #d73027)");
            div.innerHTML += `<div style="font-size:12px; text-align:center; margin-top:5px;">Temp. powietrza: ${weather.temperature.toFixed(1)}°C</div>`;
            return div;
        }
    };
    
    let currentWeatherData = { temperature: 25, wind_speed: 5, wind_direction: 270 };
    fetch(`https://api.open-meteo.com/v1/forecast?latitude=54.16&longitude=19.40&current=temperature_2m,wind_speed_10m,wind_direction_10m&timezone=Europe/Warsaw`)
        .then(response => response.json())
        .then(data => {
            currentWeatherData = {
                temperature: data.current.temperature_2m,
                wind_speed: data.current.wind_speed_10m / 3.6,
                wind_direction: data.current.wind_direction_10m
            };
        });

    map.on('overlayadd', (e) => {
        updateLegend(e.name, currentWeatherData);
        if (e.name === "Prędkość wiatru") {
            loadAndDisplayVelocity();
        }
    });

    map.on('overlayremove', (e) => {
        updateLegend(null);
        if (e.name === "Prędkość wiatru" && velocityLayer) {
            map.removeLayer(velocityLayer);
            velocityLayer = null;
        }
    });
    
    function updateLegend(layerName, weatherData) {
        const placeholder = document.querySelector('.legend-placeholder');
        placeholder.innerHTML = "";
        if (layerName && legends[layerName]) {
            placeholder.appendChild(legends[layerName](weatherData));
        }
    }

    async function loadAndDisplayVelocity() {
        if (velocityLayer) map.removeLayer(velocityLayer);
        
        const [speedTiff, dirTiff] = await Promise.all([
            GeoTIFF.fromUrl('./wyniki/rastry/predkosc_wiatru.tif'),
            GeoTIFF.fromUrl('./wyniki/rastry/kierunek_wiatru.tif')
        ]);
        
        const speedImage = await speedTiff.getImage();
        const dirImage = await dirTiff.getImage();
        
        const speedData = (await speedImage.readRasters())[0];
        const dirData = (await dirImage.readRasters())[0];
        const bbox = speedImage.getBoundingBox();

        velocityLayer = L.velocityLayer({
            displayValues: true,
            displayOptions: {
                velocityType: "Wind",
                position: "bottomleft",
                emptyString: "Brak danych",
                angleConvention: "meteo",
                speedUnit: "m/s"
            },
            data: {
                grid: {
                    dx: speedImage.getResolution()[0],
                    dy: -speedImage.getResolution()[1],
                    nx: speedImage.getWidth(),
                    ny: speedImage.getHeight(),
                    la1: bbox[3],
                    lo1: bbox[0],
                },
                u: speedData,
                v: dirData
            },
            minVelocity: 0,
            maxVelocity: currentWeatherData.wind_speed * 1.5,
            velocityScale: 0.01
        });
        velocityLayer.addTo(map);
    }
    
    overlayLayers["Pokrycie terenu"].addTo(map);
    updateLegend("Pokrycie terenu", currentWeatherData);

</script>
</body>
</html>
