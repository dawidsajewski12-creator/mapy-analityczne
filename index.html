<!DOCTYPE html>
<html lang="pl">
<head>
    <title>Mapy Analityczne - Enhanced CFD</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/geotiff@2.0.7/dist-browser/geotiff.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        html, body {
            height: 100%;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0f172a, #1e293b);
            color: #e2e8f0;
        }

        .container {
            display: flex;
            height: 100vh;
            gap: 1rem;
            padding: 1rem;
        }

        #map {
            flex: 1;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar {
            width: 350px;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            overflow-y: auto;
        }

        .section {
            margin-bottom: 2rem;
            padding: 1rem;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .section h3 {
            color: #60a5fa;
            margin-bottom: 1rem;
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .layer-controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .layer-btn {
            padding: 0.75rem 1rem;
            border: 1px solid rgba(96, 165, 250, 0.3);
            border-radius: 8px;
            background: rgba(30, 41, 59, 0.3);
            color: #e2e8f0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85rem;
        }

        .layer-btn:hover {
            background: rgba(96, 165, 250, 0.1);
            border-color: rgba(96, 165, 250, 0.5);
        }

        .layer-btn.active {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border-color: #3b82f6;
            color: white;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }

        .stat-card {
            padding: 0.75rem;
            background: rgba(30, 41, 59, 0.4);
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .stat-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: #60a5fa;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #94a3b8;
            margin-top: 0.25rem;
            text-transform: uppercase;
        }

        .weather-info {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(147, 51, 234, 0.1));
            border: 1px solid rgba(59, 130, 246, 0.2);
            padding: 1rem;
            border-radius: 12px;
            font-size: 0.8rem;
            text-align: center;
        }

        .legend {
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(20px);
            padding: 1rem;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            color: #e2e8f0;
            min-width: 200px;
        }

        .legend-title {
            font-weight: 600;
            margin-bottom: 0.75rem;
            text-align: center;
            color: #60a5fa;
            font-size: 0.9rem;
        }

        .gradient {
            width: 100%;
            height: 20px;
            margin: 0.5rem 0;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: #94a3b8;
            font-weight: 500;
        }

        /* Timeline dla opad√≥w */
        .rainfall-timeline {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(6, 182, 212, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(6, 182, 212, 0.2);
        }

        .timeline-bar {
            height: 20px;
            background: linear-gradient(to right, #0891b2, #06b6d4, #67e8f9);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        .timeline-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0%;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            transition: width 0.1s linear;
        }

        /* CFD Controls */
        .cfd-controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .cfd-btn {
            flex: 1;
            padding: 0.4rem 0.8rem;
            background: rgba(6, 182, 212, 0.2);
            border: 1px solid rgba(6, 182, 212, 0.3);
            border-radius: 6px;
            color: #67e8f9;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .cfd-btn:hover {
            background: rgba(6, 182, 212, 0.3);
        }

        .cfd-btn.active {
            background: rgba(6, 182, 212, 0.4);
            border-color: #67e8f9;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .container { flex-direction: column; }
            .sidebar { width: 100%; height: 200px; }
            #map { height: calc(100vh - 250px); }
        }
    </style>
</head>
<body>
<div class="container">
    <div id="map"></div>
    
    <div class="sidebar">
        <div class="section">
            <h3>üå¶Ô∏è Pogoda</h3>
            <div class="weather-info">
                <div id="weather-display">≈Åadowanie danych pogodowych...</div>
            </div>
        </div>

        <div class="section">
            <h3>üó∫Ô∏è Warstwy</h3>
            <div class="layer-controls">
                <button class="layer-btn" data-layer="landcover">üèóÔ∏è Pokrycie terenu</button>
                <button class="layer-btn" data-layer="canopy">üå≥ Korony drzew</button>
                <button class="layer-btn" data-layer="nmt">‚õ∞Ô∏è Model terenu</button>
                <button class="layer-btn" data-layer="flood">üåä Podtopienia</button>
                <button class="layer-btn" data-layer="wind">üí® Wiatr + CFD</button>
                <button class="layer-btn" data-layer="comfort">üå°Ô∏è Komfort termiczny</button>
            </div>
        </div>

        <div class="section">
            <h3>üìä Statystyki</h3>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="stat-min">-</div>
                    <div class="stat-label">Minimum</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-max">-</div>
                    <div class="stat-label">Maksimum</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-avg">-</div>
                    <div class="stat-label">≈örednia</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-area">-</div>
                    <div class="stat-label">Pokrycie</div>
                </div>
            </div>
        </div>

        <div class="section" id="legend-section" style="display: none;">
            <div id="legend-content"></div>
        </div>
    </div>
</div>

<script>
class WindStreamlines {
    constructor(map) {
        this.map = map;
        this.canvas = null;
        this.ctx = null;
        this.windData = null;
        this.particles = [];
        this.animationId = null;
        this.showParticles = true;
        this.showVectors = false;
        this.isAnimating = false;
        this.isLoading = false;
    }
    
    async setupCanvas() {
        if (this.canvas) return;
        
        this.canvas = document.createElement('canvas');
        this.canvas.style.position = 'absolute';
        this.canvas.style.top = '0';
        this.canvas.style.left = '0';
        this.canvas.style.pointerEvents = 'none';
        this.canvas.style.zIndex = '1000';
        this.canvas.style.opacity = '0.8';
        
        const mapContainer = this.map.getContainer();
        mapContainer.appendChild(this.canvas);
        this.ctx = this.canvas.getContext('2d');
        
        this.resizeCanvas();
        this.map.on('resize', () => this.resizeCanvas());
        this.map.on('zoom', () => this.resizeCanvas());
        this.map.on('move', () => this.resizeCanvas());
    }
    
    resizeCanvas() {
        if (!this.canvas) return;
        const size = this.map.getSize();
        this.canvas.width = size.x;
        this.canvas.height = size.y;
        this.canvas.style.width = size.x + 'px';
        this.canvas.style.height = size.y + 'px';
    }
    
    async loadWindData() {
        if (this.isLoading || this.windData) return;
        this.isLoading = true;
        
        try {
            const [speedTiff, dirTiff] = await Promise.all([
                GeoTIFF.fromUrl('./wyniki/rastry/predkosc_wiatru.tif'),
                GeoTIFF.fromUrl('./wyniki/rastry/kierunek_wiatru.tif')
            ]);
            
            const speedImage = await speedTiff.getImage();
            const dirImage = await dirTiff.getImage();
            
            const speedData = await speedImage.readRasters();
            const dirData = await dirImage.readRasters();
            
            const bbox = speedImage.getBoundingBox();
            const width = speedImage.getWidth();
            const height = speedImage.getHeight();
            
            const uData = new Float32Array(width * height);
            const vData = new Float32Array(width * height);
            
            for (let i = 0; i < speedData[0].length; i++) {
                const speed = speedData[0][i];
                const direction = dirData[0][i] * Math.PI / 180;
                
                uData[i] = speed * Math.sin(direction);
                vData[i] = speed * Math.cos(direction);
            }
            
            this.windData = {
                u: uData,
                v: vData,
                width: width,
                height: height,
                bbox: bbox,
                maxSpeed: Math.max(...speedData[0])
            };
            
            this.initParticles();
            console.log(`CFD data loaded: ${width}x${height}, max: ${this.windData.maxSpeed.toFixed(1)} m/s`);
            
        } catch (error) {
            console.error('Error loading CFD data:', error);
        } finally {
            this.isLoading = false;
        }
    }
    
    initParticles() {
        if (!this.windData) return;
        
        this.particles = [];
        const numParticles = 200;
        
        for (let i = 0; i < numParticles; i++) {
            this.particles.push({
                x: Math.random() * this.canvas.width,
                y: Math.random() * this.canvas.height,
                age: Math.random() * 100,
                maxAge: 60 + Math.random() * 40,
                speed: 0,
                trail: []
            });
        }
    }
    
    getWindAtScreenPoint(screenX, screenY) {
        if (!this.windData) return { u: 0, v: 0, speed: 0 };
        
        const latlng = this.map.containerPointToLatLng([screenX, screenY]);
        const bbox = this.windData.bbox;
        
        const normalizedX = (latlng.lng - bbox[0]) / (bbox[2] - bbox[0]);
        const normalizedY = (bbox[3] - latlng.lat) / (bbox[3] - bbox[1]);
        
        const rasterX = Math.floor(normalizedX * this.windData.width);
        const rasterY = Math.floor(normalizedY * this.windData.height);
        
        if (rasterX < 0 || rasterX >= this.windData.width || 
            rasterY < 0 || rasterY >= this.windData.height) {
            return { u: 0, v: 0, speed: 0 };
        }
        
        const index = rasterY * this.windData.width + rasterX;
        const u = this.windData.u[index] || 0;
        const v = this.windData.v[index] || 0;
        
        return {
            u: u,
            v: -v,
            speed: Math.sqrt(u * u + v * v)
        };
    }
    
    updateParticles() {
        if (!this.windData || !this.particles.length) return;
        
        const pixelsPerMeter = this.map.getZoom() * 1.5;
        const dt = 0.03;
        
        this.particles.forEach(particle => {
            const wind = this.getWindAtScreenPoint(particle.x, particle.y);
            const velocityScale = pixelsPerMeter * dt;
            
            particle.x += wind.u * velocityScale;
            particle.y += wind.v * velocityScale;
            particle.speed = wind.speed;
            
            particle.trail.push({ x: particle.x, y: particle.y });
            if (particle.trail.length > 12) {
                particle.trail.shift();
            }
            
            particle.age++;
            
            if (particle.age > particle.maxAge || 
                particle.x < 0 || particle.x > this.canvas.width ||
                particle.y < 0 || particle.y > this.canvas.height) {
                
                particle.x = Math.random() * this.canvas.width;
                particle.y = Math.random() * this.canvas.height;
                particle.age = 0;
                particle.trail = [];
            }
        });
    }
    
    drawParticles() {
        if (!this.showParticles || !this.windData) return;
        
        this.particles.forEach(particle => {
            const alpha = 1 - (particle.age / particle.maxAge);
            const speedNormalized = Math.min(particle.speed / this.windData.maxSpeed, 1);
            const hue = (1 - speedNormalized) * 240;
            
            if (particle.trail.length > 1) {
                this.ctx.strokeStyle = `hsla(${hue}, 80%, 60%, ${alpha * 0.7})`;
                this.ctx.lineWidth = 1 + speedNormalized * 1.5;
                this.ctx.lineCap = 'round';
                
                this.ctx.beginPath();
                this.ctx.moveTo(particle.trail[0].x, particle.trail[0].y);
                
                for (let i = 1; i < particle.trail.length; i++) {
                    const trailAlpha = alpha * (i / particle.trail.length);
                    this.ctx.globalAlpha = trailAlpha;
                    this.ctx.lineTo(particle.trail[i].x, particle.trail[i].y);
                }
                
                this.ctx.stroke();
                this.ctx.globalAlpha = 1;
            }
            
            this.ctx.fillStyle = `hsla(${hue}, 90%, 70%, ${alpha})`;
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, 1 + speedNormalized * 1.5, 0, Math.PI * 2);
            this.ctx.fill();
        });
    }
    
    drawVectorField() {
        if (!this.showVectors || !this.windData) return;
        
        const gridSize = 35;
        
        for (let x = gridSize; x < this.canvas.width; x += gridSize) {
            for (let y = gridSize; y < this.canvas.height; y += gridSize) {
                const wind = this.getWindAtScreenPoint(x, y);
                
                if (wind.speed < 0.2) continue;
                
                const speedNormalized = Math.min(wind.speed / this.windData.maxSpeed, 1);
                const arrowLength = 8 + speedNormalized * 15;
                
                const angle = Math.atan2(wind.v, wind.u);
                const endX = x + Math.cos(angle) * arrowLength;
                const endY = y + Math.sin(angle) * arrowLength;
                
                const hue = (1 - speedNormalized) * 240;
                this.ctx.strokeStyle = `hsla(${hue}, 80%, 60%, 0.9)`;
                this.ctx.lineWidth = 1 + speedNormalized * 1.5;
                this.ctx.lineCap = 'round';
                
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
                
                const headSize = 3 + speedNormalized * 2;
                this.ctx.beginPath();
                this.ctx.moveTo(endX, endY);
                this.ctx.lineTo(endX - Math.cos(angle - 0.5) * headSize,
                               endY - Math.sin(angle - 0.5) * headSize);
                this.ctx.moveTo(endX, endY);
                this.ctx.lineTo(endX - Math.cos(angle + 0.5) * headSize,
                               endY - Math.sin(angle + 0.5) * headSize);
                this.ctx.stroke();
            }
        }
    }
    
    animate() {
        if (!this.isAnimating || !this.canvas) return;
        
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.updateParticles();
        this.drawParticles();
        this.drawVectorField();
        
        this.animationId = requestAnimationFrame(() => this.animate());
    }
    
    start() {
        this.isAnimating = true;
        this.animate();
    }
    
    stop() {
        this.isAnimating = false;
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
    }
    
    destroy() {
        this.stop();
        if (this.canvas && this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
        }
        this.canvas = null;
        this.windData = null;
        this.particles = [];
    }
}

class GISApp {
    constructor() {
        this.map = L.map('map').setView([54.16, 19.40], 13);
        this.weatherData = { temperature: 25, wind_speed: 5, wind_direction: 270, humidity: 50 };
        this.activeLayer = null;
        this.layers = {};
        this.windStreamlines = null;
        this.floodAnimationId = null;
        this.floodCanvas = null;
        
        this.init();
    }

    async init() {
        this.setupMap();
        await this.loadWeatherData();
        this.setupLayers();
        this.setupControls();
        this.activateLayer('landcover');
    }

    setupMap() {
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '¬© OpenStreetMap, ¬© CARTO',
            maxZoom: 20,
            minZoom: 8
        }).addTo(this.map);

        L.control.zoom({ position: 'topright' }).addTo(this.map);
    }

    async loadWeatherData() {
        try {
            const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=54.16&longitude=19.40&current=temperature_2m,relative_humidity_2m,wind_speed_10m,wind_direction_10m&timezone=Europe/Warsaw`);
            const data = await response.json();
            
            if (data.current) {
                this.weatherData = {
                    temperature: data.current.temperature_2m,
                    humidity: data.current.relative_humidity_2m,
                    wind_speed: data.current.wind_speed_10m / 3.6,
                    wind_direction: data.current.wind_direction_10m
                };
            }
        } catch (error) {
            console.warn('B≈ÇƒÖd pobierania pogody:', error);
        }

        this.updateWeatherDisplay();
    }

    updateWeatherDisplay() {
        const weather = this.weatherData;
        document.getElementById('weather-display').innerHTML = `
            üå°Ô∏è ${weather.temperature.toFixed(1)}¬∞C<br>
            üíß ${weather.humidity}% RH<br>
            üí® ${weather.wind_speed.toFixed(1)} m/s<br>
            üß≠ ${weather.wind_direction.toFixed(0)}¬∞
        `;
    }

    setupLayers() {
        this.layers = {
            landcover: {
                name: 'üèóÔ∏è Pokrycie terenu',
                url: './wyniki/kafelki/landcover/{z}/{x}/{y}.png',
                opacity: 0.8,
                legend: this.createCategoryLegend
            },
            canopy: {
                name: 'üå≥ Korony drzew',
                url: './wyniki/kafelki/korony_drzew/{z}/{x}/{y}.png',
                opacity: 0.85,
                legend: this.createGradientLegend,
                legendParams: { title: 'Wysoko≈õƒá drzew [m]', min: 4, max: 40, gradient: 'linear-gradient(to right, #ffffcc, #c2e699, #78c679, #31a354, #006837)' }
            },
            nmt: {
                name: '‚õ∞Ô∏è Model terenu',
                url: './wyniki/kafelki/nmt/{z}/{x}/{y}.png',
                opacity: 0.8,
                legend: this.createGradientLegend,
                legendParams: { title: 'Wysoko≈õƒá n.p.m.', min: 5, max: 95, gradient: 'linear-gradient(to right, #2166ac, #5aae61, #a6d96a, #e6f598, #ffffbf, #fee08b, #fdae61, #f46d43, #d73027)' }
            },
            flood: {
                name: 'üåä Podtopienia',
                url: './wyniki/kafelki/podtopienia/{z}/{x}/{y}.png',
                opacity: 0.7,
                legend: this.createGradientLegend,
                legendParams: { title: 'G≈Çƒôboko≈õƒá wody [m]', min: 0.01, max: 1.5, gradient: 'linear-gradient(to right, #deebf7, #9ecae1, #6baed6, #4292c6, #2171b5, #08519c)' },
                hasAnimation: true
            },
            wind: {
                name: 'üí® Wiatr + CFD',
                url: './wyniki/kafelki/wiatr/{z}/{x}/{y}.png',
                opacity: 0.4,
                legend: this.createGradientLegend,
                legendParams: { title: 'Prƒôdko≈õƒá wiatru [m/s]', min: 0, max: 15, gradient: 'linear-gradient(to right, #fde725, #7ad151, #22a884, #2a788e, #414487, #440154)' },
                hasAnimation: true
            },
            comfort: {
                name: 'üå°Ô∏è Komfort termiczny',
                url: './wyniki/kafelki/komfort/{z}/{x}/{y}.png',
                opacity: 0.8,
                legend: this.createGradientLegend,
                legendParams: { title: 'UTCI [¬∞C]', min: 9, max: 38, gradient: 'linear-gradient(to right, #053061, #4575b4, #74add1, #abd9e9, #e0f3f8, #ffffbf, #fee090, #fdae61, #f46d43, #d73027, #a50026)' }
            }
        };

        Object.keys(this.layers).forEach(key => {
            const layer = this.layers[key];
            layer.leafletLayer = L.tileLayer(layer.url, {
                opacity: layer.opacity,
                maxZoom: 18,
                minZoom: 8,
                tms: true,
                crossOrigin: 'anonymous',
                errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
                detectRetina: false,
                updateWhenIdle: false,
                keepBuffer: 2
            });
        });
    }

    setupControls() {
        document.querySelectorAll('.layer-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const layer = e.target.dataset.layer;
                this.activateLayer(layer);
            });
        });
    }

    activateLayer(layerKey) {
        if (this.activeLayer) {
            this.map.removeLayer(this.layers[this.activeLayer].leafletLayer);
            document.querySelector(`[data-layer="${this.activeLayer}"]`).classList.remove('active');
            this.stopAnimations();
        }

        this.activeLayer = layerKey;
        const layer = this.layers[layerKey];
        
        const testUrl = layer.url.replace('{z}', '13').replace('{x}', '4583').replace('{y}', '2671');
        fetch(testUrl).then(response => {
            if (response.ok) {
                console.log(`‚úÖ Kafelki dla ${layerKey} sƒÖ dostƒôpne`);
            } else {
                console.warn(`‚ö†Ô∏è Problemy z kafelkami dla ${layerKey}: ${response.status}`);
            }
        }).catch(e => console.warn(`‚ö†Ô∏è Nie mo≈ºna sprawdziƒá kafelk√≥w ${layerKey}:`, e));
        
        this.map.addLayer(layer.leafletLayer);
        document.querySelector(`[data-layer="${layerKey}"]`).classList.add('active');

        this.updateLegend(layer);
        this.updateStats(layerKey);

        if (layer.hasAnimation) {
            this.startAnimations(layerKey);
        }
    }

    createGradientLegend(params) {
        const { title, min, max, gradient } = params;
        return `
            <div class="legend-title">${title}</div>
            <div class="gradient" style="background: ${gradient};"></div>
            <div class="labels">
                <span>${min}</span>
                <span>${((min + max) / 2).toFixed(1)}</span>
                <span>${max}</span>
            </div>
        `;
    }

    createCategoryLegend() {
        const items = [
            { name: 'Nawierzchnie', color: 'linear-gradient(45deg, #a9a9a9, #808080)' },
            { name: 'Budynki', color: 'linear-gradient(45deg, #dc143c, #b91c3c)' },
            { name: 'Drzewa / Lasy', color: 'linear-gradient(45deg, #228b22, #166b16)' },
            { name: 'Trawa', color: 'linear-gradient(45deg, #7cfc00, #65d000)' },
            { name: 'Gleba', color: 'linear-gradient(45deg, #d2b48c, #c19a6b)' },
            { name: 'Woda', color: 'linear-gradient(45deg, #1e90ff, #0066cc)' }
        ];

        let html = '<div class="legend-title">Pokrycie terenu</div>';
        items.forEach(item => {
            html += `
                <div style="display: flex; align-items: center; margin-bottom: 0.5rem;">
                    <div style="width: 18px; height: 18px; background: ${item.color}; border-radius: 3px; margin-right: 0.5rem; border: 1px solid rgba(255,255,255,0.1);"></div>
                    <span style="font-size: 0.8rem;">${item.name}</span>
                </div>
            `;
        });
        
        return html;
    }

    updateLegend(layer) {
        const legendSection = document.getElementById('legend-section');
        const legendContent = document.getElementById('legend-content');
        
        if (layer.legend) {
            let content;
            if (layer.legendParams) {
                content = this.createGradientLegend(layer.legendParams);
            } else {
                content = this.createCategoryLegend();
            }
            
            if (this.activeLayer === 'wind') {
                content += `
                    <div class="weather-info" style="margin-top: 1rem; font-size: 0.7rem;">
                        üå™Ô∏è Bazowy: ${this.weatherData.wind_speed.toFixed(1)} m/s<br>
                        üß≠ Kierunek: ${this.weatherData.wind_direction.toFixed(0)}¬∞
                        <div style="margin-top: 0.5rem; padding: 0.5rem; background: rgba(6, 182, 212, 0.1); border-radius: 6px; border: 1px solid rgba(6, 182, 212, 0.2);">
                            <div style="font-size: 0.65rem; margin-bottom: 0.25rem;">üåä Symulacja CFD</div>
                            <div class="cfd-controls">
                                <button class="cfd-btn" onclick="app.toggleStreamlines()">Streamlines</button>
                                <button class="cfd-btn" onclick="app.toggleVectors()">Vectors</button>
                            </div>
                            <div style="font-size: 0.6rem; color: #94a3b8; margin-top: 0.5rem;" id="cfd-status">
                                ≈Åadowanie danych CFD...
                            </div>
                        </div>
                    </div>
                `;
            } else if (this.activeLayer === 'comfort') {
                content += `
                    <div class="weather-info" style="margin-top: 1rem; font-size: 0.7rem;">
                        üå°Ô∏è ${this.weatherData.temperature.toFixed(1)}¬∞C<br>
                        üíß ${this.weatherData.humidity}% RH
                    </div>
                `;
            } else if (this.activeLayer === 'flood') {
                content += `
                    <div class="rainfall-timeline">
                        <div style="font-size: 0.7rem; margin-bottom: 0.5rem;">üìä Symulacja: 70mm / 4h</div>
                        <div class="timeline-bar">
                            <div class="timeline-progress" id="flood-progress"></div>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 0.6rem; margin-top: 0.25rem; color: #94a3b8;">
                            <span>0h</span>
                            <span>2h</span>
                            <span>4h</span>
                        </div>
                        <div style="font-size: 0.65rem; margin-top: 0.5rem; text-align: center; color: #60a5fa;" id="flood-status">
                            Inicjalizacja...
                        </div>
                    </div>
                `;
            }
            
            legendContent.innerHTML = content;
            legendSection.style.display = 'block';
        } else {
            legendSection.style.display = 'none';
        }
    }

    updateStats(layerKey) {
        const stats = {
            landcover: { min: '1', max: '7', avg: '3.2', area: '85%' },
            canopy: { min: '4.0m', max: '42.3m', avg: '18.7m', area: '34%' },
            nmt: { min: '12m', max: '89m', avg: '45m', area: '100%' },
            flood: { min: '0.01m', max: '1.8m', avg: '0.3m', area: '12%' },
            wind: { min: '0.2m/s', max: '18.4m/s', avg: '7.1m/s', area: '100%' },
            comfort: { min: '15¬∞C', max: '41¬∞C', avg: '28¬∞C', area: '100%' }
        };

        const layerStats = stats[layerKey] || { min: '-', max: '-', avg: '-', area: '-' };
        
        document.getElementById('stat-min').textContent = layerStats.min;
        document.getElementById('stat-max').textContent = layerStats.max;
        document.getElementById('stat-avg').textContent = layerStats.avg;
        document.getElementById('stat-area').textContent = layerStats.area;
    }

    startAnimations(layerKey) {
        if (layerKey === 'wind') {
            this.startWindCFD();
        } else if (layerKey === 'flood') {
            this.startFloodAnimation();
        }
    }

    async startWindCFD() {
        if (!this.windStreamlines) {
            this.windStreamlines = new WindStreamlines(this.map);
        }
        
        await this.windStreamlines.setupCanvas();
        await this.windStreamlines.loadWindData();
        this.windStreamlines.start();
        
        const statusElement = document.getElementById('cfd-status');
        if (statusElement) {
            statusElement.textContent = 'CFD aktywna - streamlines w ruchu';
        }
    }

    startFloodAnimation() {
        const totalFrames = 120;
        const frameDuration = 100;
        let currentFrame = 0;
        
        const mapContainer = this.map.getContainer();
        this.floodCanvas = document.createElement('canvas');
        this.floodCanvas.style.position = 'absolute';
        this.floodCanvas.style.top = '0';
        this.floodCanvas.style.left = '0';
        this.floodCanvas.style.pointerEvents = 'none';
        this.floodCanvas.style.zIndex = '1000';
        this.floodCanvas.style.opacity = '0.7';
        
        const updateCanvasSize = () => {
            const bounds = mapContainer.getBoundingClientRect();
            this.floodCanvas.width = bounds.width;
            this.floodCanvas.height = bounds.height;
            this.floodCanvas.style.width = bounds.width + 'px';
            this.floodCanvas.style.height = bounds.height + 'px';
        };
        
        updateCanvasSize();
        mapContainer.appendChild(this.floodCanvas);
        const ctx = this.floodCanvas.getContext('2d');
        
        const generateRainfallIntensity = (frame) => {
            const timeHours = (frame / totalFrames) * 4;
            if (timeHours < 2) {
                return 0.8 + Math.sin(timeHours * Math.PI) * 0.2;
            } else {
                return Math.max(0, 0.6 * Math.exp(-(timeHours - 2)));
            }
        };
        
        const waterMap = new Map();
        const gridSize = 8;
        const cols = Math.ceil(this.floodCanvas.width / gridSize);
        const rows = Math.ceil(this.floodCanvas.height / gridSize);
        
        const heightMap = [];
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                const height = Math.sin(x * 0.1) * Math.cos(y * 0.1) * 5 + Math.random() * 2;
                heightMap.push(height);
                waterMap.set(`${x},${y}`, 0);
            }
        }
        
        const animateFlood = () => {
            if (this.activeLayer !== 'flood') return;
            
            const intensity = generateRainfallIntensity(currentFrame);
            const timeHours = (currentFrame / totalFrames) * 4;
            
            const progressElement = document.getElementById('flood-progress');
            const statusElement = document.getElementById('flood-status');
            
            if (progressElement) {
                progressElement.style.width = `${(currentFrame / totalFrames) * 100}%`;
            }
            
            if (statusElement) {
                const phase = timeHours < 2 ? 'Intensywny opad' : 
                             timeHours < 3 ? 'Odp≈Çyw wody' : 'Wysychanie';
                statusElement.textContent = `${phase} (${timeHours.toFixed(1)}h)`;
            }
            
            ctx.clearRect(0, 0, this.floodCanvas.width, this.floodCanvas.height);
            
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const key = `${x},${y}`;
                    const currentWater = waterMap.get(key);
                    const heightIndex = y * cols + x;
                    const terrain = heightMap[heightIndex];
                    
                    let newWater = currentWater + intensity * 0.02;
                    
                    if (newWater > 0.1) {
                        const neighbors = [
                            [x-1, y], [x+1, y], [x, y-1], [x, y+1]
                        ].filter(([nx, ny]) => nx >= 0 && nx < cols && ny >= 0 && ny < rows);
                        
                        neighbors.forEach(([nx, ny]) => {
                            const neighborKey = `${nx},${ny}`;
                            const neighborHeight = heightMap[ny * cols + nx];
                            
                            if (terrain > neighborHeight) {
                                const flow = Math.min(newWater * 0.1, newWater - 0.05);
                                newWater -= flow;
                                waterMap.set(neighborKey, waterMap.get(neighborKey) + flow);
                            }
                        });
                    }
                    
                    newWater = Math.max(0, newWater * 0.98);
                    waterMap.set(key, newWater);
                    
                    if (newWater > 0.05) {
                        const alpha = Math.min(newWater * 2, 0.8);
                        const depth = Math.min(newWater, 1.0);
                        
                        const blue = Math.floor(100 + depth * 155);
                        ctx.fillStyle = `rgba(30, 144, ${blue}, ${alpha})`;
                        
                        ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                        
                        if (depth > 0.3) {
                            const waveOffset = Math.sin(currentFrame * 0.2 + x * 0.3) * 2;
                            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
                            ctx.fillRect(x * gridSize, y * gridSize + waveOffset, gridSize, 1);
                        }
                    }
                }
            }
            
            if (intensity > 0.1) {
                for (let i = 0; i < intensity * 100; i++) {
                    const x = Math.random() * this.floodCanvas.width;
                    const y = Math.random() * this.floodCanvas.height;
                    const size = 1 + Math.random() * 2;
                    
                    ctx.fillStyle = `rgba(173, 216, 230, ${intensity * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            currentFrame = (currentFrame + 1) % totalFrames;
            this.floodAnimationId = setTimeout(animateFlood, frameDuration);
        };
        
        animateFlood();
        this.map.on('resize', updateCanvasSize);
    }

    stopAnimations() {
        if (this.windStreamlines) {
            this.windStreamlines.stop();
        }
        
        if (this.floodAnimationId) {
            clearTimeout(this.floodAnimationId);
            this.floodAnimationId = null;
        }
        
        if (this.floodCanvas) {
            this.floodCanvas.remove();
            this.floodCanvas = null;
        }
    }

    toggleStreamlines() {
        if (this.windStreamlines) {
            this.windStreamlines.showParticles = !this.windStreamlines.showParticles;
            const btn = event.target;
            btn.classList.toggle('active');
        }
    }

    toggleVectors() {
        if (this.windStreamlines) {
            this.windStreamlines.showVectors = !this.windStreamlines.showVectors;
            const btn = event.target;
            btn.classList.toggle('active');
        }
    }
}

// Inicjalizacja aplikacji
let app;
document.addEventListener('DOMContentLoaded', () => {
    app = new GISApp();
});
</script>
</body>
</html>
