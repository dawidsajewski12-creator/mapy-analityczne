<!DOCTYPE html>
<html lang="pl">
<head>
    <title>Mapy Analityczne - Statyczna Wersja</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
    <style>
        /* ... (wszystkie style CSS pozostajÄ… bez zmian) ... */
        html, body { height: 100%; font-family: 'Inter', sans-serif; background: #0f172a; color: #e2e8f0; }
        .container { display: flex; height: 100vh; gap: 1rem; padding: 1rem; }
        #map { flex: 1; border-radius: 16px; overflow: hidden; box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5); border: 1px solid #334155; position: relative; }
        .sidebar { width: 350px; background: #1e293b; border-radius: 16px; padding: 1.5rem; overflow-y: auto; }
        .section { margin-bottom: 1.5rem; } .section h3 { color: #60a5fa; margin-bottom: 1rem; font-size: 0.9rem; text-transform: uppercase; }
        .layer-btn { width: 100%; padding: 0.75rem; border: 1px solid #334155; border-radius: 8px; background: #293548; color: #e2e8f0; cursor: pointer; transition: all 0.2s ease; }
        .layer-btn:hover { background: #334155; } .layer-btn.active { background: #3b82f6; border-color: #3b82f6; color: white; }
        /* Canvas dla animacji wiatru */
        #wind-canvas { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 401; }
    </style>
</head>
<body>
<div class="container">
    <div id="map">
        </div>
    <div class="sidebar">
        </div>
</div>

<script>
// NOWA KLASA: Warstwa animacji przepÅ‚ywu
L.FlowLayer = L.Layer.extend({
    options: {
        imageUrl: './wyniki/flow_map.png',
        particleCount: 2000,
        fadeFactor: 0.97, // Jak szybko zanikajÄ… Å›lady
        speedFactor: 0.15, // MnoÅ¼nik prÄ™dkoÅ›ci czÄ…stek
        particleSize: 1.2
    },

    initialize: function (options) {
        L.setOptions(this, options);
        this._particles = [];
    },

    onAdd: function (map) {
        this._map = map;
        this._canvas = L.DomUtil.create('canvas', 'leaflet-layer');
        this._canvas.id = 'wind-canvas';
        this.getPane().appendChild(this._canvas);

        this._ctx = this._canvas.getContext('2d');
        this._ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
        this._ctx.lineWidth = this.options.particleSize;

        map.on('moveend', this._reset, this);
        
        this._loadImage();
    },

    onRemove: function (map) {
        this.getPane().removeChild(this._canvas);
        map.off('moveend', this._reset, this);
        if (this._animationFrame) {
            cancelAnimationFrame(this._animationFrame);
        }
    },

    _loadImage: function () {
        this._flowImage = new Image();
        this._flowImage.src = this.options.imageUrl;
        this._flowImage.onload = () => {
            this._createOffscreenCanvas();
            this._reset();
            this._animate();
        };
        this._flowImage.onerror = () => {
            console.warn('Nie moÅ¼na zaÅ‚adowaÄ‡ flow_map.png. Animacja wiatru nie bÄ™dzie dostÄ™pna.');
        };
    },

    _createOffscreenCanvas: function() {
        this._offscreenCanvas = document.createElement('canvas');
        this._offscreenCanvas.width = this._flowImage.width;
        this._offscreenCanvas.height = this._flowImage.height;
        this._offscreenCtx = this._offscreenCanvas.getContext('2d');
        this._offscreenCtx.drawImage(this._flowImage, 0, 0);
    },

    _reset: function () {
        if (!this._flowImage || !this._flowImage.complete) return;
        
        const size = this._map.getSize();
        this._canvas.width = size.x;
        this._canvas.height = size.y;
        
        L.DomUtil.setPosition(this._canvas, this._map.containerPointToLayerPoint([0, 0]));

        this._particles = [];
        for (let i = 0; i < this.options.particleCount; i++) {
            this._particles.push(this._createParticle());
        }
    },

    _createParticle: function(p) {
        const x = Math.random() * this._canvas.width;
        const y = Math.random() * this._canvas.height;
        return { x: x, y: y, px: x, py: y, age: Math.random() * 100 };
    },

    _getFlowAt: function(x, y) {
        const bounds = this._map.getBounds();
        const mapLngDelta = bounds.getEast() - bounds.getWest();
        const mapLatDelta = bounds.getNorth() - bounds.getSouth();

        const point = this._map.layerPointToLatLng(L.point(x, y));
        
        const imgX = Math.floor(((point.lng - bounds.getWest()) / mapLngDelta) * this._flowImage.width);
        const imgY = Math.floor(((bounds.getNorth() - point.lat) / mapLatDelta) * this._flowImage.height);
        
        if (imgX < 0 || imgX >= this._flowImage.width || imgY < 0 || imgY >= this._flowImage.height) {
            return null;
        }

        const pixel = this._offscreenCtx.getImageData(imgX, imgY, 1, 1).data;
        if (pixel[3] < 10) return null; // Przezroczysty = przeszkoda

        const h = pixel[0] / 255;
        const v = pixel[2] / 255; // JasnoÅ›Ä‡ (prÄ™dkoÅ›Ä‡)
        
        const angle = h * 2 * Math.PI - Math.PI; // Konwersja z Hue na kÄ…t
        const speed = v * this.options.speedFactor * 30; // 30 to magiczna liczba skalujÄ…ca
        
        return { u: speed * Math.cos(angle), v: speed * Math.sin(angle) };
    },

    _animate: function() {
        if (!this._map) return;

        const g = this._ctx;
        g.globalCompositeOperation = 'destination-in';
        g.fillStyle = `rgba(0, 0, 0, ${this.options.fadeFactor})`;
        g.fillRect(0, 0, this._canvas.width, this._canvas.height);
        g.globalCompositeOperation = 'lighter';
        
        this._particles.forEach(p => {
            p.age++;
            if (p.age > 200) {
                Object.assign(p, this._createParticle());
            }

            const flow = this._getFlowAt(p.x, p.y);
            if (flow) {
                p.px = p.x;
                p.py = p.y;
                p.x += flow.u;
                p.y += flow.v;

                g.beginPath();
                g.moveTo(p.px, p.py);
                g.lineTo(p.x, p.y);
                g.stroke();
            } else {
                 Object.assign(p, this._createParticle());
            }
        });
        
        this._animationFrame = requestAnimationFrame(this._animate.bind(this));
    }
});

class GISApp {
    constructor() {
        this.map = L.map('map').setView([54.16, 19.40], 13);
        this.activeLayer = null;
        this.layers = {};
        this.flowLayer = new L.FlowLayer(); // Instancja warstwy animacji
        this.init();
    }

    async init() {
        this.setupMap();
        this.setupLayers();
        this.setupControls();
        this.activateLayer('landcover');
    }

    setupMap() {
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: 'Â© OpenStreetMap, Â© CARTO', maxZoom: 20
        }).addTo(this.map);
    }
    
    setupLayers() {
        this.layers = {
            // ... definicje warstw landcover, canopy, nmt, flood, comfort bez zmian ...
            wind: {
                name: 'ðŸ’¨ Wiatr',
                url: './wyniki/kafelki/wiatr/{z}/{x}/{y}.png',
                opacity: 0.5,
                legend: this.createGradientLegend,
                legendParams: { title: 'PrÄ™dkoÅ›Ä‡ wiatru [m/s]', min: 0, max: 15, gradient: 'linear-gradient(to right, #fde725, #22a884, #414487, #440154)' },
                hasAnimation: true // Nowy atrybut
            },
        };

        Object.keys(this.layers).forEach(key => {
            const layer = this.layers[key];
            layer.leafletLayer = L.tileLayer(layer.url, {
                opacity: layer.opacity, maxZoom: 18, tms: true
            });
        });
    }

    setupControls() {
        document.querySelectorAll('.layer-btn').forEach(btn => {
            btn.addEventListener('click', (e) => this.activateLayer(e.target.dataset.layer));
        });
    }

    activateLayer(layerKey) {
        if (this.activeLayer) {
            this.map.removeLayer(this.layers[this.activeLayer].leafletLayer);
            document.querySelector(`[data-layer="${this.activeLayer}"]`).classList.remove('active');
            // WyÅ‚Ä…cz animacjÄ™, jeÅ›li poprzednia warstwa jÄ… miaÅ‚a
            if (this.layers[this.activeLayer].hasAnimation) {
                 this.map.removeLayer(this.flowLayer);
            }
        }

        this.activeLayer = layerKey;
        const layer = this.layers[layerKey];
        
        this.map.addLayer(layer.leafletLayer);
        document.querySelector(`[data-layer="${layerKey}"]`).classList.add('active');

        // WÅ‚Ä…cz animacjÄ™, jeÅ›li nowa warstwa jej wymaga
        if (layer.hasAnimation) {
            this.map.addLayer(this.flowLayer);
        }

        this.updateLegend(layer);
        // updateStats...
    }
    
    // ... pozostaÅ‚e metody (createGradientLegend, updateLegend, itd.) bez zmian ...
}

document.addEventListener('DOMContentLoaded', () => {
    new GISApp();
});
</script>
</body>
</html>
