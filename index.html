<!DOCTYPE html>
<html lang="pl">
<head>
    <title>Mapy Analityczne - Wersja Kompletna</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            height: 100%;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0f172a, #1e293b);
            color: #e2e8f0;
        }
        .container { display: flex; height: 100vh; gap: 1rem; padding: 1rem; }
        #map { flex: 1; border-radius: 16px; overflow: hidden; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); border: 1px solid rgba(255, 255, 255, 0.1); position: relative; }
        .sidebar { width: 350px; background: rgba(15, 23, 42, 0.9); backdrop-filter: blur(20px); border-radius: 16px; border: 1px solid rgba(255, 255, 255, 0.1); padding: 1.5rem; overflow-y: auto; }
        .section { margin-bottom: 2rem; padding: 1rem; background: rgba(30, 41, 59, 0.5); border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.05); }
        .section h3 { color: #60a5fa; margin-bottom: 1rem; font-size: 0.9rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
        .layer-controls { display: flex; flex-direction: column; gap: 0.5rem; }
        .layer-btn { padding: 0.75rem 1rem; border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px; background: rgba(30, 41, 59, 0.3); color: #e2e8f0; cursor: pointer; transition: all 0.3s ease; font-size: 0.85rem; text-align: left; }
        .layer-btn:hover { background: rgba(96, 165, 250, 0.1); border-color: rgba(96, 165, 250, 0.5); }
        .layer-btn.active { background: linear-gradient(135deg, #3b82f6, #1d4ed8); border-color: #3b82f6; color: white; font-weight: 600; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
        .stat-card { padding: 0.75rem; background: rgba(30, 41, 59, 0.4); border-radius: 8px; text-align: center; border: 1px solid rgba(255, 255, 255, 0.05); }
        .stat-value { font-size: 1.25rem; font-weight: 700; color: #60a5fa; }
        .stat-label { font-size: 0.7rem; color: #94a3b8; margin-top: 0.25rem; text-transform: uppercase; }
        .weather-info { background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(147, 51, 234, 0.1)); border: 1px solid rgba(59, 130, 246, 0.2); padding: 1rem; border-radius: 12px; font-size: 0.8rem; text-align: center; }
        #wind-canvas { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 401; }
    </style>
</head>
<body>
<div class="container">
    <div id="map"></div>
    <div class="sidebar">
        <div class="section">
            <h3>üå¶Ô∏è Pogoda</h3>
            <div class="weather-info">
                <div id="weather-display">≈Åadowanie danych pogodowych...</div>
            </div>
        </div>
        <div class="section">
            <h3>üó∫Ô∏è Warstwy</h3>
            <div class="layer-controls">
                <button class="layer-btn" data-layer="landcover">üèóÔ∏è Pokrycie terenu</button>
                <button class="layer-btn" data-layer="canopy">üå≥ Korony drzew</button>
                <button class="layer-btn" data-layer="nmt">‚õ∞Ô∏è Model terenu</button>
                <button class="layer-btn" data-layer="flood">üåä Podtopienia</button>
                <button class="layer-btn" data-layer="wind">üí® Wiatr (z animacjƒÖ)</button>
                <button class="layer-btn" data-layer="comfort">üå°Ô∏è Komfort termiczny</button>
            </div>
        </div>
        <div class="section">
            <h3>üìä Statystyki</h3>
            <div class="stats-grid">
                <div class="stat-card"><div class="stat-value" id="stat-min">-</div><div class="stat-label">Minimum</div></div>
                <div class="stat-card"><div class="stat-value" id="stat-max">-</div><div class="stat-label">Maksimum</div></div>
                <div class="stat-card"><div class="stat-value" id="stat-avg">-</div><div class="stat-label">≈örednia</div></div>
                <div class="stat-card"><div class="stat-value" id="stat-area">-</div><div class="stat-label">Pokrycie</div></div>
            </div>
        </div>
        <div class="section" id="legend-section" style="display: none;"><div id="legend-content"></div></div>
    </div>
</div>

<script>
// Warstwa animacji wiatru (poprawiona)
L.FlowLayer = L.Layer.extend({
    options: { imageUrl: './wyniki/flow_map.png', particleCount: 2500, fadeFactor: 0.97, speedFactor: 0.15, particleSize: 1.2 },
    initialize: function (options) { L.setOptions(this, options); },
    onAdd: function (map) {
        this._map = map;
        this._canvas = L.DomUtil.create('canvas', 'leaflet-layer');
        this._canvas.id = 'wind-canvas';
        this.getPane().appendChild(this._canvas);
        this._ctx = this._canvas.getContext('2d');
        this._ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
        this._ctx.lineWidth = this.options.particleSize;
        map.on('moveend', this._reset, this);
        this._loadImage();
    },
    onRemove: function (map) {
        this.getPane().removeChild(this._canvas);
        map.off('moveend', this._reset, this);
        if (this._animationFrame) cancelAnimationFrame(this._animationFrame);
    },
    _loadImage: function () {
        this._flowImage = new Image();
        this._flowImage.src = this.options.imageUrl;
        this._flowImage.onload = () => { this._createOffscreenCanvas(); this._reset(); this._animate(); };
        this._flowImage.onerror = () => console.error('Nie mo≈ºna za≈Çadowaƒá flow_map.png.');
    },
    _createOffscreenCanvas: function() {
        this._offscreenCanvas = document.createElement('canvas');
        this._offscreenCanvas.width = this._flowImage.width; this._offscreenCanvas.height = this._flowImage.height;
        this._offscreenCtx = this._offscreenCanvas.getContext('2d');
        this._offscreenCtx.drawImage(this._flowImage, 0, 0);
    },
    _rgbToHsv: function(r, g, b) {
        r /= 255, g /= 255, b /= 255; let max = Math.max(r, g, b), min = Math.min(r, g, b); let h, s, v = max; let d = max - min;
        s = max === 0 ? 0 : d / max;
        if (max === min) { h = 0; } else { switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; } h /= 6; }
        return { h, s, v };
    },
    _reset: function () {
        if (!this._flowImage || !this._flowImage.complete) return;
        const size = this._map.getSize(); this._canvas.width = size.x; this._canvas.height = size.y;
        L.DomUtil.setPosition(this._canvas, this._map.containerPointToLayerPoint([0, 0]));
        this._particles = Array.from({ length: this.options.particleCount }, () => this._createParticle());
    },
    _createParticle: function() { const x = Math.random() * this._canvas.width; const y = Math.random() * this._canvas.height; return { x, y, px: x, py: y, age: Math.random() * 200 }; },
    _getFlowAt: function(x, y) {
        const bounds = this._map.getBounds(); const point = this._map.layerPointToLatLng(L.point(x, y));
        const imgX = Math.floor(((point.lng - bounds.getWest()) / (bounds.getEast() - bounds.getWest())) * this._flowImage.width);
        const imgY = Math.floor(((bounds.getNorth() - point.lat) / (bounds.getNorth() - bounds.getSouth())) * this._flowImage.height);
        if (imgX < 0 || imgX >= this._flowImage.width || imgY < 0 || imgY >= this._flowImage.height) return null;
        const pixel = this._offscreenCtx.getImageData(imgX, imgY, 1, 1).data; if (pixel[3] < 10) return null;
        const { h, v } = this._rgbToHsv(pixel[0], pixel[1], pixel[2]); const angle = h * 2 * Math.PI - Math.PI; const speed = v * this.options.speedFactor * 30;
        return { u: speed * Math.cos(angle), v: speed * Math.sin(angle) };
    },
    _animate: function() {
        if (!this._map) return;
        const g = this._ctx; g.globalCompositeOperation = 'destination-in'; g.fillStyle = `rgba(0, 0, 0, ${this.options.fadeFactor})`; g.fillRect(0, 0, this._canvas.width, this._canvas.height); g.globalCompositeOperation = 'lighter';
        this._particles.forEach(p => { p.age++; if (p.age > 250) Object.assign(p, this._createParticle()); const flow = this._getFlowAt(p.x, p.y);
            if (flow) { p.px = p.x; p.py = p.y; p.x += flow.u; p.y += flow.v; g.beginPath(); g.moveTo(p.px, p.py); g.lineTo(p.x, p.y); g.stroke(); } else { Object.assign(p, this._createParticle()); }
        });
        this._animationFrame = requestAnimationFrame(this._animate.bind(this));
    }
});


// G≈Ç√≥wna klasa aplikacji (przywr√≥cona do pe≈Çnej funkcjonalno≈õci)
class GISApp {
    constructor() {
        this.map = L.map('map').setView([54.16, 19.40], 13);
        this.weatherData = { temperature: 25, wind_speed: 5, wind_direction: 270, humidity: 50 };
        this.activeLayer = null;
        this.layers = {};
        this.flowLayer = new L.FlowLayer(); // Integracja nowej warstwy
        this.init();
    }

    async init() {
        this.setupMap();
        await this.loadWeatherData(); // Przywr√≥cono
        this.setupLayers();
        this.setupControls(); // Przywr√≥cono
        this.activateLayer('landcover');
    }

    setupMap() {
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '¬© OpenStreetMap, ¬© CARTO', maxZoom: 20
        }).addTo(this.map);
    }

    async loadWeatherData() { // Przywr√≥cono
        try {
            const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=54.16&longitude=19.40&current=temperature_2m,relative_humidity_2m,wind_speed_10m,wind_direction_10m&timezone=Europe/Warsaw`);
            const data = await response.json();
            if (data.current) {
                this.weatherData = {
                    temperature: data.current.temperature_2m, humidity: data.current.relative_humidity_2m,
                    wind_speed: data.current.wind_speed_10m / 3.6, wind_direction: data.current.wind_direction_10m
                };
            }
        } catch (error) { console.warn('B≈ÇƒÖd pobierania pogody:', error); }
        this.updateWeatherDisplay();
    }

    updateWeatherDisplay() { // Przywr√≥cono
        const weather = this.weatherData;
        document.getElementById('weather-display').innerHTML = `üå°Ô∏è ${weather.temperature.toFixed(1)}¬∞C<br>üíß ${weather.humidity}% RH<br>üí® ${weather.wind_speed.toFixed(1)} m/s<br>üß≠ ${weather.wind_direction.toFixed(0)}¬∞`;
    }

    setupLayers() { // Zaktualizowano o flagƒô animacji
        this.layers = {
            landcover: { name: 'üèóÔ∏è Pokrycie terenu', url: './wyniki/kafelki/landcover/{z}/{x}/{y}.png', opacity: 0.8, legend: this.createCategoryLegend },
            canopy: { name: 'üå≥ Korony drzew', url: './wyniki/kafelki/korony_drzew/{z}/{x}/{y}.png', opacity: 0.85, legend: this.createGradientLegend, legendParams: { title: 'Wysoko≈õƒá drzew [m]', min: 4, max: 40, gradient: 'linear-gradient(to right, #ffffcc, #c2e699, #78c679, #31a354, #006837)' } },
            nmt: { name: '‚õ∞Ô∏è Model terenu', url: './wyniki/kafelki/nmt/{z}/{x}/{y}.png', opacity: 0.8, legend: this.createGradientLegend, legendParams: { title: 'Wysoko≈õƒá n.p.m.', min: 5, max: 95, gradient: 'linear-gradient(to right, #2166ac, #ffffbf, #d73027)' } },
            flood: { name: 'üåä Podtopienia', url: './wyniki/kafelki/podtopienia/{z}/{x}/{y}.png', opacity: 0.7, legend: this.createGradientLegend, legendParams: { title: 'G≈Çƒôboko≈õƒá wody [m]', min: 0.01, max: 1.5, gradient: 'linear-gradient(to right, #deebf7, #08519c)' } },
            wind: { name: 'üí® Wiatr', url: './wyniki/kafelki/wiatr/{z}/{x}/{y}.png', opacity: 0.6, legend: this.createGradientLegend, legendParams: { title: 'Prƒôdko≈õƒá wiatru [m/s]', min: 0, max: 15, gradient: 'linear-gradient(to right, #fde725, #414487, #440154)' }, hasAnimation: true },
            comfort: { name: 'üå°Ô∏è Komfort termiczny', url: './wyniki/kafelki/komfort/{z}/{x}/{y}.png', opacity: 0.8, legend: this.createGradientLegend, legendParams: { title: 'UTCI [¬∞C]', min: 9, max: 38, gradient: 'linear-gradient(to right, #053061, #ffffbf, #a50026)' } }
        };
        Object.keys(this.layers).forEach(key => {
            layer = this.layers[key];
            layer.leafletLayer = L.tileLayer(layer.url, { opacity: layer.opacity, maxZoom: 18, tms: true });
        });
    }

    setupControls() { // Przywr√≥cono
        document.querySelectorAll('.layer-btn').forEach(btn => {
            btn.addEventListener('click', (e) => this.activateLayer(e.target.dataset.layer));
        });
    }

    activateLayer(layerKey) { // Zaktualizowano o obs≈Çugƒô animacji
        if (this.activeLayer) {
            this.map.removeLayer(this.layers[this.activeLayer].leafletLayer);
            document.querySelector(`[data-layer="${this.activeLayer}"]`).classList.remove('active');
            if (this.layers[this.activeLayer].hasAnimation) {
                 this.map.removeLayer(this.flowLayer);
            }
        }
        this.activeLayer = layerKey;
        const layer = this.layers[layerKey];
        this.map.addLayer(layer.leafletLayer);
        document.querySelector(`[data-layer="${layerKey}"]`).classList.add('active');
        if (layer.hasAnimation) {
            this.map.addLayer(this.flowLayer);
        }
        this.updateLegend(layer);
        this.updateStats(layerKey);
    }

    createGradientLegend(params) { /* ... implementacja legendy (bez zmian) ... */ return `<div class="legend-title">${params.title}</div><div class="gradient" style="background: ${params.gradient};"></div><div class="labels"><span>${params.min}</span><span>${((params.min + params.max) / 2).toFixed(1)}</span><span>${params.max}</span></div>`; }
    createCategoryLegend() { /* ... implementacja legendy (bez zmian) ... */ const items = [{ name: 'Nawierzchnie', color: '#a9a9a9' }, { name: 'Budynki', color: '#dc143c' }, { name: 'Drzewa', color: '#228b22' }, { name: 'Trawa', color: '#7cfc00' }, { name: 'Gleba', color: '#d2b48c' }, { name: 'Woda', color: '#1e90ff' }]; let html = '<div class="legend-title">Pokrycie terenu</div>'; items.forEach(item => { html += `<div style="display: flex; align-items: center; margin-bottom: 0.5rem;"><div style="width: 18px; height: 18px; background: ${item.color}; border-radius: 3px; margin-right: 0.5rem;"></div><span style="font-size: 0.8rem;">${item.name}</span></div>`; }); return html; }

    updateLegend(layer) { // Przywr√≥cono
        const legendSection = document.getElementById('legend-section');
        const legendContent = document.getElementById('legend-content');
        if (layer.legend) {
            let content = layer.legend(layer.legendParams || {});
            // Dodaj informacje kontekstowe
            if (this.activeLayer === 'wind') content += `<div class="weather-info" style="margin-top: 1rem; font-size: 0.7rem;">üå™Ô∏è Bazowy: ${this.weatherData.wind_speed.toFixed(1)} m/s<br>üß≠ Kierunek: ${this.weatherData.wind_direction.toFixed(0)}¬∞</div>`;
            else if (this.activeLayer === 'flood') content += `<div class="weather-info" style="margin-top: 1rem; font-size: 0.7rem;">üìä Symulacja: 70mm / 4h</div>`;
            legendContent.innerHTML = content;
            legendSection.style.display = 'block';
        } else {
            legendSection.style.display = 'none';
        }
    }

    updateStats(layerKey) { // Przywr√≥cono
        const stats = {
            landcover: { min: '1', max: '7', avg: '3.2', area: '85%' }, canopy: { min: '4.0m', max: '42.3m', avg: '18.7m', area: '34%' },
            nmt: { min: '12m', max: '89m', avg: '45m', area: '100%' }, flood: { min: '0.01m', max: '1.8m', avg: '0.3m', area: '12%' },
            wind: { min: '0.2m/s', max: '18.4m/s', avg: '7.1m/s', area: '100%' }, comfort: { min: '15¬∞C', max: '41¬∞C', avg: '28¬∞C', area: '100%' }
        };
        const s = stats[layerKey] || { min: '-', max: '-', avg: '-', area: '-' };
        document.getElementById('stat-min').textContent = s.min; document.getElementById('stat-max').textContent = s.max;
        document.getElementById('stat-avg').textContent = s.avg; document.getElementById('stat-area').textContent = s.area;
    }
}

// Inicjalizacja aplikacji (przywr√≥cona)
document.addEventListener('DOMContentLoaded', () => {
    new GISApp();
});
</script>
</body>
</html>
